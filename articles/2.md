浏览器缓存是浏览器自动保存的常见文档的副本

当浏览器向服务器请求资源时，如果本地有已缓存的副本，就可以从本地缓存而不是从原始服务器获取资源

本篇文章将从HTTP请求和响应头入手，解析浏览器缓存的具体机制

> 注意，本文只讨论浏览器中内建的私有缓存，公有缓存（代理服务器缓存等）不在本文的讨论范围之内

## 基本原理

当浏览器向服务器发送一个GET请求时，事实上会经历以下几个步骤：
* 解析 —— 缓存对报文进行解析，提取出URL和各种首部
* 查询 —— 缓存查看是否有本地副本可用，如果没有，就向服务器获取一份副本（并将其保存在本地）
* 文档过期检测 —— 缓存查看已缓存副本是否已经过期，如果没有过期，则使用此副本，如果过期，则进入下一步
* 服务器再验证 —— 缓存检查已过期副本与原始服务器副本是否一致，如果不一致，则获取一份新的副本，如果一致，则使用当前副本

浏览器缓存的基本原理其实就是这样，前两步没有什么难点，只是单纯的检查是否有缓存而已，我们直接来探讨第三步和第四步的机制：

**文档过期检测**和**服务器再验证**，也被称为**强缓存**和**协商缓存**

## 文档过期检测（强缓存）
通过特殊的的HTTP首部**Cache-Control**和**Expires** ，HTTP让原始服务器向每个**响应消息头**都附加了一个“过期日期”，声明内容的过期时间

### Expires首部：
首先是HTTP/1.0+的Expires首部，该字段指定一个**绝对的过期时间**，以服务器时间为参考时间
例如：
```
Expires: Thu, 01 Feb 2018 11:40:30 GMT
```
在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求

但是，由于Expires使用的是绝对时间，依赖于计算机时钟的正确设置，于是，就有了下面的Cache-Control首部，现今我们也大多使用Cache-Control首部

### Cache-Control首部：
Cache-Control是属于HTTP/1.1的字段，该字段定义了资源缓存的最大有效时间（到无法使用为止），是一个**相对时间**
```
Cache-Control: max-age=480000
```

除了max-age之外，Cache-Control还包含了一些其他可以携带的值，这里只列几个常用的：
1. no-store : 禁止缓存对响应进行复制，即不缓存文档（包括请求和响应）
2. no-cache : 资源被缓存，但是在与原始服务器进行服务器再验证之前，不能将其提供给客户端使用

其他可选值可以上[MDN文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)上查找

### 补充：Pragma首部
在很多网站的请求头里我们也可以发现这样一个首部
```
Pragma: no-cache 
```
这其实是HTTP/1.0字段, 通常设置为Pragma:no-cache, 作用同Cache-Control:no-cache。当一个no-cache请求发送给一个不遵循HTTP/1.1的服务器时, 客户端应该包含pragma

因此，当我们在浏览器中勾选disable cache时, 浏览器也会自动带上pragma字段

### 优先级：
在浏览器缓存里, Cache-Control的优先级高于Expires，所以如果两者同时使用，浏览器以优先级更高的Cache-Control为准

### 小结
文档过期检测基本就由这些HTTP首部来进行控制，如果检测到缓存未过期，即命中强缓存，则浏览器**不会发送请求到服务器**，而是直接从缓存中取出响应消息，Chrome下的状态码是 200 OK (from disk cache) 或者 200 OK (from memory cache)，如下：

![image](https://note.youdao.com/yws/api/personal/file/E635A7C8ECE843AEBC2A56803362DC3E?method=download&shareKey=5d1b26f21577c7c6d410ad67e95744e8)

如果检测到缓存已过期，即未命中强缓存，则进行服务器再验证，即协商缓存

## 服务器再验证（协商缓存）
仅仅是已缓存过期了并不意味着它与处于原始服务器上目前处于活跃状态的文档有什么实际的区别，此时需要询问原始服务器文档是否已经发生了变化，即服务器再验证

* 如果再验证显示内容发生了变化，浏览器会获取一份新的文档副本，并将其存储在旧文档的位置上，并将携带新首部的新文档作为响应消息，此时浏览器返回带有新主体的200响应

* 如果再验证显示内容没有发生变化，浏览器只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新，并将此首部作为响应消息的首部，此时浏览器返回一个304 Not Modified响应，直接从缓存取出文档

那么如何实现再验证呢？HTTP定义了5个条件请求首部来进行再验证。

> 需要注意的是，这种条件验证方法实际上是向服务器发送一个“条件GET”请求，只有在文档与缓存中现有的副本不同时，才回送主体，否则从缓存中取出文档作为主体

### If-Modified-Since

### If-None-Match
